### **MyBatis框架的优缺点**

#### **一、MyBatis的核心优点**

MyBatis的成功在于它在**SQL控制力**和**开发效率**之间找到了一个极佳的平衡点。

| 优点                            | 具体说明与价值                                               |
| :------------------------------ | :----------------------------------------------------------- |
| **1. SQL与代码解耦，灵活可控**  | **核心优势**。SQL被独立写在XML文件或注解中，与Java代码分离。<br>• **利于维护**：DBA或开发者可以专注优化SQL，无需在代码中拼接字符串。<br>• **灵活极致**：开发者拥有SQL的**完全控制权**，可以编写复杂查询、利用数据库特有函数和语法，进行深度性能优化。这是它对比全ORM框架（如Hibernate）的最大优势。 |
| **2. 大幅减少JDBC样板代码**     | 封装了JDBC底层的连接创建、语句准备、结果集遍历、资源释放等重复性工作，通常能减少**50%以上**的相关代码，让开发者更专注于SQL和业务逻辑。 |
| **3. 学习曲线平缓，易于上手**   | 核心概念简单（SQL映射）。对于熟悉SQL和Java的开发者来说，入门门槛远低于需要掌握复杂概念（如对象状态、HQL）的全功能ORM框架。 |
| **4. 提供轻量级的对象关系映射** | 通过 `<resultMap>` 等映射标签，能智能地将查询结果集自动映射到Java对象（POJO）上，解决了手动从`ResultSet`取数据的繁琐，实现了“半自动化”ORM。 |
| **5. 与Spring生态无缝集成**     | 官方提供了 `mybatis-spring` 集成模块，配置简单，可以方便地使用Spring的事务管理、IoC容器等特性，是Spring技术栈中数据访问层的标准选择之一。 |
| **6. 功能强大的动态SQL**        | 通过OGNL表达式和 `<if>`, `<choose>`, `<foreach>` 等标签，可以在XML中灵活地构建动态SQL，避免在Java代码中拼接复杂且易错的SQL字符串。 |
| **7. 插件机制提供扩展能力**     | 提供了基于拦截器的插件机制，允许开发者对MyBatis的核心行为（如执行器、语句处理器）进行拦截和增强，可以实现分页、性能监控、数据脱敏等通用功能。 |

#### **二、MyBatis的主要缺点与考量**

使用MyBatis也意味着需要承担一些相应的代价和挑战。

| 缺点                          | 具体说明与影响                                               |
| :---------------------------- | :----------------------------------------------------------- |
| **1. SQL编写工作量大**        | **最显著的缺点**。每个数据操作都需要编写对应的SQL和映射配置。对于字段多、关联复杂的查询，XML文件会变得冗长，维护成本增加。相比之下，Hibernate/JPA在简单CRUD场景下几乎无需写SQL。 |
| **2. 数据库移植性较差**       | 虽然MyBatis底层兼容所有JDBC数据库，但**SQL本身是数据库相关的**。如果SQL中使用了数据库特有函数或语法（如Oracle的 `ROWNUM` vs MySQL的 `LIMIT`），在切换数据库时需要重写大量SQL，移植成本高。 |
| **3. 对开发者SQL能力要求高**  | 框架将SQL的控制权完全交给了开发者，也就意味着**性能调优的责任也完全在开发者身上**。要写出高性能的SQL，需要开发者具备良好的数据库知识和SQL优化能力。 |
| **4. 需手动维护对象关系映射** | 虽然提供了映射功能，但关联查询（一对多、多对多）的嵌套结果映射（`<collection>`, `<association>`）配置相对复杂，且需要开发者手动维护，不如Hibernate的级联操作自动化程度高。 |
| **5. 缓存机制相对薄弱**       | 其自带的二级缓存默认是基于本地Map的，在分布式环境下容易产生脏数据，功能和管理粒度不如Hibernate的二级缓存强大。生产环境中常被禁用，转而使用Redis等集中式缓存。 |
